{"componentChunkName":"component---src-templates-post-template-js","path":"/post/Python Fundemental","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Python Fundamentals - Sequences","date":"2021-02-09T00:00:00.000Z"},"html":"<h1>Table of Contents</h1>\n<ul>\n<li>TOC\n{:toc}</li>\n</ul>\n<h1>Overview</h1>\n<p>In python's standard library, we have the following sequence types:</p>\n<ul>\n<li><code>list</code>. Heterogenous and mutable.</li>\n<li><code>tuple</code>. Heterogenous and immutable.</li>\n<li><code>collections.deque</code>. Heterogenous and mutable.</li>\n<li><code>str</code>. Flat and immutable.</li>\n<li><code>bytes</code>. Flat and immutable.</li>\n<li><code>bytearray</code>. Flat and mutable.</li>\n<li><code>memoryview</code>. Flat and mutable.</li>\n<li><code>array.array</code>. Flat and mutable.</li>\n</ul>\n<p>A data structure is <strong>flat/heterogenous</strong> if it can only hold the same type or hold different types, and is <strong>mutable/immutable</strong> if its contents can be modified.</p>\n<p>Listcomps are fairly simple, so I will just give a few examples of them here before we jump to genexps.</p>\n<h3>Cartesian Products</h3>\n<pre><code class=\"language-python\">>>> letters = ['a','b','c']\n>>> numbers = [1,2,3]\n>>> product = [(letter, number) for letter in letters for number in numbers]\n>>> product\n[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]\n</code></pre>\n<h3>Restricted listcomp</h3>\n<pre><code class=\"language-python\">>>> letters = ['a','b','c']\n>>> filtered_letters = [letter for letter in letters if letter != 'c']\n>>> filtered_letters\n['a', 'b']\n</code></pre>\n<h1>List &#x26; Tuples &#x26; Generic Sequences</h1>\n<h2>Generator Expressions (genexp)</h2>\n<p>Generator expressions can be done to save space in the case that an entire list is not needed. We replace listcomp with genexp in the above cartesian product example:</p>\n<pre><code class=\"language-python\">>>> letters = ['a','b','c']\n>>> numbers = [1,2,3]\n>>> for element in ('%s %s' % (l, n) for l in letters for n in numbers):\n...     print(element)\n...\na 1\na 2\na 3\nb 1\nb 2\nb 3\nc 1\nc 2\nc 3\n</code></pre>\n<p>Here, we did not create a cartesian product list and scan it to print. This is clearly more efficient.</p>\n<h2><code>tuple</code></h2>\n<p>Tuples are immutable lists which serve as records with no field names. In particular, the position of the item in the tuple may have a semantic meaning. We unpack a tuple like so:</p>\n<pre><code class=\"language-python\">>>> coordinates = (1,2)\n>>> _, longitude = coordinates\n>>> longitude\n2\n</code></pre>\n<p>Another way to unpack is by using the star operator:</p>\n<pre><code class=\"language-python\">>>> coordinates = (1,2)\n>>> f = lambda x, y: x+y\n>>> f(*coordinates)\n3\n</code></pre>\n<p>You can use these two in mixture:</p>\n<pre><code class=\"language-python\">>>> long_tup = (1,2,3,4,5,6,7)\n>>> x,y,*z = long_tup\n>>> x\n1\n>>> y\n2\n>>> z\n[3, 4, 5, 6, 7]\n</code></pre>\n<h3><code>namedtuple</code></h3>\n<p><code>namedtuple</code>s are a part of the <code>collections</code> package which basically, as the name implies, have names to each field. Just as we create tuples as nameless records, we have <code>namedtuples</code> for records with names. These should be used more often:</p>\n<pre><code class=\"language-python\">>>> from collections import namedtuple\n>>> Snek = namedtuple('Snake', ['name', 'length'])\n>>> an = Snek('anaconda', '4.511')\n>>> py = Snek('python', '3.7')\n>>> py\nSnake(name='python', length='3.7')\n>>> an\nSnake(name='anaconda', length='4.511')\n>>> py[1]\n'3.7'\n</code></pre>\n<h2>Advanced Slicing</h2>\n<h3>Slice Assignment</h3>\n<p>You can modify portions of a <strong>mutable</strong> sequence using slice, i.e. add, delete, etc:</p>\n<h4>Add</h4>\n<pre><code class=\"language-python\">>>> l = [1,2,3]\n>>> l[1:1] = ['a','b','c']\n>>> l\n[1, 'a', 'b', 'c', 2, 3]\n</code></pre>\n<h4>Delete</h4>\n<pre><code class=\"language-python\">>>> l = [1,2,3]\n>>> del l[1:]\n>>> l\n[1]\n</code></pre>\n<h3>No More Magic - Readable Slices</h3>\n<p>When you call <code>seq[start:stop:step]</code>, python calls <code>seq.__getitem__(slice(start, stop, step))</code>, where <code>slice</code> is actually an object. Thus, you can actually create <strong>named constant slices</strong> for better readability, like so:</p>\n<pre><code class=\"language-python\">>>> NAME = slice(0,4)\n>>> FIRST = slice(4,10)\n>>> LAST = slice(10, None)\n>>> items\n['a   123   456', 'b   23    4567']\n>>> for item in items:\n...     print(\"Name: {}, First: {}, Last: {}\".format(item[NAME].strip(), item[FIRST].strip(), item[LAST].strip()))\n...\nName: a, First: 123, Last: 456\nName: b, First: 23, Last: 4567\n</code></pre>\n<p>This makes your functions less \"magic\" and more readable for future developers.</p>\n<h3>Multi-Argument Slices - How?</h3>\n<p>When you use <code>numpy</code>'s multidimensional array class, <code>np.ndarray</code>, how does it handle multiple arguments?</p>\n<p>When you call <code>a[i,j]</code>, you are actually calling <code>a.__getitem__((i, j))</code>, so that the arguments inside of <code>[]</code> is packaged as a tuple. <code>numpy</code> defined custom <code>__getitem__</code> so it can accept tuples like above, unlike built-in types.</p>\n<p>When you use <code>a[i, ...]</code>, it is another multi-argument slice, equivalent to <code>a[i, :, :, :]</code> if it was a 4-dimensional matrix. The <code>...</code> is considered a special keyword, an alias to <code>Ellipsis</code> object, from the <code>ellipsis</code> class. Think of <code>Ellipsis</code> as <code>True</code> or <code>False</code>, and its class <code>ellipsis</code> like <code>bool</code>.</p>\n<h2><code>+, *</code> Operators With Sequences</h2>\n<h3>Reference Issues with <code>*</code></h3>\n<p><strong>Never do this:</strong> <code>[[]] * 3</code>. When you evaluate it at first, you'll see <code>[[],[],[]]</code>. Innocent looking enough, but they are references to the same list. <strong>Do this instead:</strong> <code>[[] for _ in range(3)]</code>, so that each object is constructed individually.</p>\n<h3><code>__iadd__</code> and <code>__imul__</code> With Immutable Objects</h3>\n<p>When you try to augment a sequence using <code>+=</code> or <code>*=</code>, it invokes the magic functions <code>__iadd__</code> and <code>__imul__</code>. If the object does not have these functions, it falls back to <code>__add__</code> and <code>__mul__</code>. For immutable objects like tuples, this sometimes spells trouble:</p>\n<pre><code class=\"language-python\">>>> l = (1,2,3)\n>>> id(l)\n4510772608\n>>> l += (4,5,6)\n>>> l\n(1, 2, 3, 4, 5, 6)\n>>> id(l)\n4510680840\n</code></pre>\n<p><strong>These are not the same objects.</strong> What's happening underneath the hood is equivalent to <code>l = l + (4,5,6)</code>, which means we created a new tuple! <strong>To be precise, the tuple container is replaced while the references to objects inside are the same before and after.</strong></p>\n<h3>Weirdest Corner Case</h3>\n<pre><code class=\"language-python\">>>> t = ([],)\n>>> t[0] += [1]\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nTypeError: 'tuple' object does not support item assignment\n>>> t\n([1],)\n</code></pre>\n<p>Wait... So we modified the list inside the tuple, but it also gave us an error? Why is this true? <strong>Because this is not an atomic operation.</strong> Specifically, it looks like this:</p>\n<pre><code class=\"language-python\">>>> temp_t = t\n>>> temp_idx = 0\n>>> mutable_item = temp_t[temp_idx]\n>>> mutable_item += [1]\n>>> temp_t[temp_idx] = mutable_item\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nTypeError: 'tuple' object does not support item assignment\n</code></pre>\n<p>You can also disassemble python code and view the bytecode to see a similar process.</p>\n<h2><code>bisect</code> For Sorted Sequences</h2>\n<h3>Searching Using <code>bisect()</code></h3>\n<p>There are 2 bisect functions, <code>bisect_left</code> and <code>bisect_right</code>. By default, <code>bisect.bisect</code> is an alias for <code>bisect.bisect_right</code>. These functions are basically binary searches for sequences with generic ordered types. The difference between the two is subtle - when you try to search an object and the object itself is present in the sequence, <code>bisect_left</code> returns the element's index, and <code>bisect_right</code> returns the index plus one:</p>\n<pre><code class=\"language-python\">>>> from bisect import bisect_right, bisect_left\n>>> l = [1,2,3]\n>>> bisect_right(l, 2)\n2\n>>> bisect_left(l, 2)\n1\n</code></pre>\n<p>One application is <strong>discretization</strong>. For example, from numerical scores on an exam to one's final grade, which is in discrete intervals of <code>F, D, C, B, A</code>. Or, waist size to shirt sizes:</p>\n<pre><code class=\"language-python\">>>> def shirt_size(size, cutoff=[30,60], sizes=['Small', 'Medium', 'Large']):\n...     return sizes[bisect_right(cutoff, size)]\n...\n>>> shirt_size(20)\n'Small'\n>>> shirt_size(30)\n'Medium'\n>>> shirt_size(50)\n'Medium'\n>>> shirt_size(60)\n'Large'\n>>> shirt_size(100)\n'Large'\n</code></pre>\n<p>Here, we use <code>bisect_right</code> because we would rather want the person to fit comfortably in a larger t-shirt in case their waist size was at the cutoff. If you want to look like you're bigger than you actually are(like me), then you would use <code>bisect_left</code>.</p>\n<h3>Inserting Using <code>insort()</code></h3>\n<p>We use <code>bisect.insort</code> to add an element into a sorted sequence:</p>\n<pre><code class=\"language-python\">>>> import bisect\n>>> l = [1,3,5,7]\n>>> for i in range(4):\n...     bisect.insort(l, i*2)\n...     print(l)\n...\n[0, 1, 3, 5, 7]\n[0, 1, 2, 3, 5, 7]\n[0, 1, 2, 3, 4, 5, 7]\n[0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre>\n<p><code>insort</code> has extra keyword arguments to insert in a sorted subsequence, and insort left or right like bisect. Once again, this can be applied to more than just lists. Any ordered collection will do, like <code>array</code>s!</p>\n<h1>Homogenous Array Types</h1>\n<h2><code>array</code></h2>\n<p><strong>Arrays are underrated and underused. They are so, so much faster than <code>list</code>s. <code>list</code>s are the default, but don't be lazy when you need the performance.</strong> <code>array</code>s contain the bit &#x26; byte level representation of primitive data types, and it's basically a C-style array. To create an array:</p>\n<pre><code class=\"language-python\">>>> from array import array\n>>> import numpy as np\n>>> nums = array('d', (np.random.random() for _ in range(10)))\n>>> for num in nums:\n...     print(num)\n...\n0.2076318634616442\n0.5052559930909137\n0.26556051714640794\n0.3538229563850064\n0.24394891007765362\n0.829697244498978\n0.8050680531932854\n0.7540974416748557\n0.5157377814111441\n0.6025949390048687\n>>> with open('temp.bin', 'wb') as f:\n...     nums.tofile(f)\n...\n</code></pre>\n<p>And then we see the saved binary file:</p>\n<pre><code>ls -la temp.bin\n-rw-r--r--  1 dev  staff  80 Jun 27 16:18 temp.bin\n</code></pre>\n<p>Nice. It's small and compact in binary format. <code>numpy</code> arrays do something similar. <code>bytes</code> and <code>bytearray</code> are simply specific types of <code>array</code> that will be discussed in detail later.</p>\n<h2><code>memoryview</code></h2>\n<p><code>memoryview</code> is like a slice of an <code>array</code>. There is no copying, everything is referenced and is usually mutable. Here we change the content of the first double in an <code>array</code> by casting the memoryview to unsigned 8-bit ints, and modifying it:</p>\n<pre><code class=\"language-python\">>>> from array import array\n>>> nums = array('d', [1,2,3])\n>>> mv = memoryview(nums)\n>>> mvc = mv.cast('B')\n>>> mvc.tolist()\n[0, 0, 0, 0, 0, 0, 240, 63, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 8, 64]\n>>> mvc[0] = 10\n>>> nums\narray('d', [1.0000000000000022, 2.0, 3.0])\n</code></pre>\n<p>Most of the time, you probably don't want to use this though.</p>\n<h1>Deques &#x26; Queues</h1>\n<h2><code>deque</code></h2>\n<p><code>collections</code> supplies with us a <code>deque</code> container which is heterogenous. It has the standard <code>append</code> and <code>pop</code> operations. On top of it, it has a couple cool functions like <code>rotate</code>, <code>extend</code> and <code>extendleft</code>.</p>\n<p><code>rotate()</code> takes in a single integer as argument, and rotates the deque in that direction. Why no <code>rotateleft</code> like <code>extend</code>? Because you can supply a negative number to rotate in the other direction. By default, <code>rotate(k)</code> moves the i-th element to the <code>(i+k) % N</code>-th place in the deque, where <code>N</code> is the size of the container.</p>\n<pre><code class=\"language-python\">>>> from collections import deque\n>>> dq = deque(\"abcdefg\", maxlen=4)\n>>> dq\ndeque(['d', 'e', 'f', 'g'], maxlen=4)\n>>> dq.rotate(2)\n>>> dq\ndeque(['f', 'g', 'd', 'e'], maxlen=4)\n>>> dq.rotate(-1)\n>>> dq\ndeque(['g', 'd', 'e', 'f'], maxlen=4)\n>>> dq.extend(\"abc\")\n>>> dq\ndeque(['f', 'a', 'b', 'c'], maxlen=4)\n>>> dq.extendleft(\"gfe\")\n>>> dq\ndeque(['e', 'f', 'g', 'f'], maxlen=4)\n</code></pre>\n<h2>Different Queues</h2>\n<p>There are a lot of different queue containers in python. You can technically use a <code>deque</code> as a queue itself too. However, for more complicated applications where asynchronicity is a key factor, insertion and popping from a queue may be tricky. Here, we use threadsafe <code>queue</code> library with its <code>Queue</code>, <code>LifoQueue</code> (which is literally a stack), and <code>PriorityQueue</code>. When you call <code>pop</code> on an empty default queue here, it will wait until an item has been inserted, rather than return an error message. <code>multiprocessing</code> and <code>asyncio</code> implements its own queues as well.</p>"}},"pageContext":{"slug":"Python Fundemental"}},"staticQueryHashes":[]}